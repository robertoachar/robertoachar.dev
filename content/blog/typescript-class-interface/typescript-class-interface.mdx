---
slug: typescript-class-interface
title: TypeScript - Classes vs Interfaces
description: Neste artigo pretendo apresentar uma compara√ß√£o entre a utiliza√ß√£o de `classes` e `interfaces`.
date: 2017-08-14
category: Artigo
tags: [javascript, typescript]
photo: ./photo.jpg
photoCredit: Giammarco Boscaro
photoLink: https://unsplash.com/photos/UkOpMcslmX8
photoAlt: Um lindo lago de √°gua azul, cercado por √°rvores e pedras
---

- Introdu√ß√£o
- Preparando o ambiente de desenvolvimento
- Construindo os testes
- Analisando o comportamento com Interfaces
- Analisando o comportamento com Classes
- Conclus√£o

## Introdu√ß√£o

`TypeScript` possui o conceito de `classes` e `interfaces`, onde ambos podem ser utilizados para representar o modelo de dados dos nossos objetos. Uma d√∫vida que encontro bastante em f√≥runs √© a seguinte:

> Devo utilizar classes ou interfaces para representar meu modelo de dados?

O objetivo desse artigo √© apresentar o veredicto final e esclarecer qualquer d√∫vida referente ao assunto.

## Preparando o ambiente de desenvolvimento

Nessa se√ß√£o vou descrever os passos que utilizei para preparar o ambiente de desenvolvimento para realizar os testes de compara√ß√£o.

- Criando o projeto

```bash
$ npm init -y
```

- Instalando as depend√™ncias de desenvolvimento

```bash
$ npm install --save-dev concurrently
$ npm install --save-dev typescript
```

- Criando o ponto de entrada

Criei o diret√≥rio `src` e dentro dele adicionei o arquivo `index.ts` com o seguinte conte√∫do.

```typescript
console.log('It works!');
```

- Definindo as configura√ß√µes de transpila√ß√£o

Na raiz do projeto, criei o arquivo `tsconfig.json` com as seguintes configura√ß√µes.

```json
{
  "compilerOptions": {
    "outDir": "./build",
    "allowJs": true,
    "target": "es5"
  },
  "include": ["./src/**/*"]
}
```

Esse arquivo ir√° transpilar os arquivos `.ts` que est√£o no diret√≥rio `src` para o diret√≥rio `build`.

- Configurando a transpila√ß√£o e execu√ß√£o do projeto

Criei o `script` de inicializa√ß√£o do projeto no arquivo `package.json`.

```json
...
  "scripts": {
    "start": "concurrently \"tsc -w\" \"nodemon build/index.js\" "
  },
...
```

O comando `tsc -w` coloca o compilador em modo `watch` e a cada altera√ß√£o nos arquivos do diret√≥rio `src`, o compilador transpila o c√≥digo para o diret√≥rio `build` automaticamente. O comando `nodemon build/index.js` executa o projeto. Caso algum arquivo `.js` seja alterado, o `nodemon` reinicia a execu√ß√£o.

- Executando o projeto

```bash
$ npm start
```

- Validando o ambiente de desenvolvimento

O arquivo `index.js` dever√° ser criado no diret√≥rio `build` e a sa√≠da do programa dever√° ser `It works!`.

## Construindo os testes

O cen√°rio mais comum para utilizarmos `classes` ou `interfaces` √© quando fazemos chamadas em API para que os dados sejam exibidos em nosso front-end. Para a execu√ß√£o dos testes vou utilizar a biblioteca `node-fetch` e a API do Star Wars: [https://swapi.co/](https://swapi.co/).

- Instalando a biblioteca `node-fetch`

```bash
$ npm install node-fetch
```

- Construindo a chamada da API

```typescript
// src/index.ts

import * as fetch from 'node-fetch';

fetch('http://swapi.co/api/people/1')
  .then((response) => response.json())
  .then((person) => {
    console.log(person.name);
  });
```

O ponto mais importante a observar no c√≥digo acima, √© que `person` ser√° **implicitamente** do tipo `any`, pois o compilador n√£o tem como identificar seu tipo automaticamente. Como o tipo de `person` √© `any`, o _IntelliSense_ n√£o √© capaz de reconhecer o tipo.

![VS Code n√£o consegue reconhecer o tipo de `person`](images/typescript-any.gif)

√â nesse ponto que precisaremos definir o nosso modelo. E a pergunta que n√£o quer calar:

> Devo utilizar classes ou interfaces?

## Analisando o comportamento com Interfaces

Para o nosso primeiro teste, iremos construir nosso modelo utilizando `interface`.

```typescript
// src/index.ts

import * as fetch from 'node-fetch';

interface Person {
  name: String;
}

fetch('http://swapi.co/api/people/1')
  .then((response) => response.json())
  .then((person: Person) => {
    console.log(person.name);
  });
```

No c√≥digo acima, estamos definindo **explicitamente** que o tipo de `person` √© `Person`. Como o tipo de `person` est√° explicitamente definido, o `IntelliSense` √© capaz de reconhecer o tipo.

![VS Code √© capaz de reconher o tipo de `person`](images/typescript-interface.gif)

- Analisando o resultado da transpila√ß√£o

Transpilando o c√≥digo acima para `JavaScript` temos o seguinte resultado.

```javascript
// build/index.js

var fetch = require('node-fetch');
fetch('http://swapi.co/api/people/1')
  .then(function(response) {
    return response.json();
  })
  .then(function(person) {
    console.log(person.name);
  });
```

## Analisando o comportamento com Classes

Para o nosso √∫ltimo teste, iremos construir nosso modelo utilizando `class`.

```typescript
// src/index.ts

import * as fetch from 'node-fetch';

class Person {
  name: String;
}

fetch('http://swapi.co/api/people/1')
  .then((response) => response.json())
  .then((person: Person) => {
    console.log(person.name);
  });
```

No c√≥digo acima, estamos definindo **explicitamente** que o tipo de `person` √© `Person`. Como o tipo de `person` est√° explicitamente definido, o `IntelliSense` √© capaz de reconhecer o tipo.

![VS Code √© capaz de reconher o tipo de `person`](images/typescript-class.gif)

- Analisando o resultado da transpila√ß√£o

Transpilando o c√≥digo acima para `JavaScript` temos o seguinte resultado.

```javascript
// build/index.js

var fetch = require('node-fetch');
var Person = (function() {
  function Person() {}
  return Person;
})();
fetch('http://swapi.co/api/people/1')
  .then(function(response) {
    return response.json();
  })
  .then(function(person) {
    console.log(person.name);
  });
```

WOW üòØüòØüòØ!

Reparem que a classe `Person` foi transpilada para o c√≥digo `JavaScript` mas n√£o √© utilizada em nenhuma parte do c√≥digo.

Esse c√≥digo √© totalmente in√∫til.

```javascript
// build/index.js

...
var Person = (function () {
    function Person() {
    }
    return Person;
}());
...
```

## Conclus√£o

Acredito que tenha ficado claro qual a melhor forma de representar os modelos de dados. As `interfaces` ir√£o representar os dados, mas ser√£o completamente removidas durante a transpila√ß√£o. O grande problema de utilizar `classes` √© a quantidade de c√≥digo desnecess√°rio que ser√° gerado em um projeto com dezenas de objetos.
